<!-- Generated from 8a6c1b5 on 2023-11-27 @ 11:01 with Emacs 27.1 (Org mode 9.3) -->
<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><meta author="J. Dylan White"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="stylesheet" href="https://jdylanwhite.github.io/css/code.css"/><link rel="stylesheet" href="https://jdylanwhite.github.io/css/site.css"/><title>Initial Build - J. Dylan White</title></head><body><header class="site-header"><div class="container"><div class="site-title"><a class="site-name" href="/">J. Dylan White</a> </div></div><div class="site-masthead"><div class="container"><nav class="nav"><a class="nav-link" href="/">Home</a> <a class="nav-link" href="/projects/">Projects</a> <a class="nav-link" href="/dotfiles/">Dotfiles</a> </nav></div></div></header><div class="container"><div class="site-post"><h1 class="site-post-title">Initial Build</h1><p class="site-post-meta">September 23, 2023</p><div id="content">
<h2><a id="initial-build-of-a-minimal-site" class="anchor" href="#initial-build-of-a-minimal-site">¶</a>Initial Build of a Minimal Site</h2><div class="outline-text-2" id="text-org066cfab">
<p>
This is the first step in building my website. Looking forward, I want to rely on typing the content of my page using <a href="https://orgmode.org/">Org Mode</a>. This is a sort of markdown that comes built into <a href="https://www.gnu.org/software/emacs/">Emacs</a> that really goes far beyond a &ldquo;sort of markdown&rdquo; that I unfairly stated. It&rsquo;s pretty awesome and has more functionality that I could begin to imagine, let along describe. I also want to be able to convert <a href="https://jupyter.org/">Jupyter Notebooks</a>, but I&rsquo;m going to figure that part out later. The output here will be far from a finished product, but this is a solid first step.
</p>
</div>

<h2><a id="setting-up-emacs-and-org-mode-publishing" class="anchor" href="#setting-up-emacs-and-org-mode-publishing">¶</a>Setting Up Emacs and Org Mode Publishing</h2><div class="outline-text-2" id="text-orga188122">
<p>
Following this guide, <a href="https://www.youtube.com/watch?v=AfkrzFodoNw">Build Your Website with Org Mode</a> by <a href="https://systemcrafters.net/">SystemCrafters</a>, it&rsquo;s easy to get started. The idea here is that you write each of your site&rsquo;s pages as individual Org Mode documents, and then you use Org Mode&rsquo;s publishing system to convert those documents into individual HTML files in a stucture that mirrors the Org Mode content.
</p>
</div>

<h3><a id="creating-the-build-site-script" class="anchor" href="#creating-the-build-site-script">¶</a>Creating the Build Site Script</h3><div class="outline-text-3" id="text-org0e29428">
<p>
We start off by building the Elisp script that we will run with base Emacs (no configuration loaded). This is built to be used anywhere by anyone with Emacs 25 or higher installed. This is important because later, we&rsquo;ll use a virtual machine to run our script from scratch each time we push a commit. This section won&rsquo;t be vastly different from David&rsquo;s very helpful SystemCrafters video, but I want to include it because it&rsquo;s where I am starting, and I&rsquo;ll on from there quite a bit.
</p>

<p>
We start off our build script, <code>build-site.el</code>, by loading the Org Mode publishing system, <code>ox-publish</code>.
</p>

<pre><span class="org-comment-delimiter">;; </span><span class="org-comment">Load the publishing system</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">This generates the HTML output from org-mode documents</span>
(<span class="org-keyword">require</span> '<span class="org-constant">ox-publish</span>)</pre>

<p>
Next, we need to install some additional dependencies. Initially, we&rsquo;ll just install <code>htmlize</code>. Without it, code blocks, such as the ones on this page, do not show up with any syntax highlighting. Most posts on this site are going to have code blocks, so I definitely want to include syntax hightlighting! First though, we need to add the MELPA package repository and refresh the contents of that repository so we can install the dependencies.
</p>

<pre><span class="org-comment-delimiter">;; </span><span class="org-comment">Set the package installation directory so that packages aren't stored in</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">the ~/.emacs.d/elpa path.</span>
(<span class="org-keyword">require</span> '<span class="org-constant">package</span>)
(<span class="org-keyword">setq</span> package-user-dir (expand-file-name <span class="org-string">"./.packages"</span>))
(<span class="org-keyword">setq</span> package-archives '((<span class="org-string">"melpa"</span> . <span class="org-string">"https://melpa.org/packages/"</span>)
                         (<span class="org-string">"elpa"</span> . <span class="org-string">"https://elpa.gnu.org/packages/"</span>)))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Initialize the package system</span>
(package-initialize)
(<span class="org-keyword">unless</span> package-archive-contents
  (package-refresh-contents))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Install dependencies - htmlize is needed for code syntax highlighting</span>
(package-install 'htmlize)</pre>

<p>
Now, we&rsquo;ll customize some of the HTML output by changing a few variables associated with Org Mode&rsquo;s publisher. When the Org documents are exported to HTML, they include a few things I don&rsquo;t want on my site, such as a HTML validation link and some default JavaScript and styling. We can also point to a specific style sheet here.
</p>

<p>
<b>Note</b>: This is useful for now, but later, we&rsquo;ll change this. These variables all impact the header and footer of the site, but later we&rsquo;ll only use Org Mode to publish the <i>body</i> of the content and let Jekyll handle the rest of the content.
</p>

<pre><span class="org-comment-delimiter">;; </span><span class="org-comment">Customize the HTML output</span>
(<span class="org-keyword">setq</span>
 <span class="org-comment-delimiter">;; </span><span class="org-comment">Don't add the HTML Validate link at the bottom of our published page</span>
 org-html-validation-link nil
 <span class="org-comment-delimiter">;; </span><span class="org-comment">Don't add the default JavaScript</span>
 org-html-head-include-scripts nil
 <span class="org-comment-delimiter">;; </span><span class="org-comment">Don't use the default styles</span>
 org-html-head-include-default-style nil
 <span class="org-comment-delimiter">;; </span><span class="org-comment">Use a pre-built CSS</span>
 org-html-head <span class="org-string">"&lt;link rel=\"stylesheet\" href=\"https://cdn.simplecss.org/simple.min.css\" /&gt;"</span>)</pre>

<p>
We need to tell Org Mode what exactly we want to publish and where to publish it to. For now, the website root directory is <code>website</code>, all of my Org Mode documents are in a subdirectory called <code>base-directory</code>, and I want to send my exported HTML files to a subdirectory called <code>public</code>. We can also handle a few other items here, such as turning off the Table of Contents, author name, and time stamp.
</p>

<pre><span class="org-comment-delimiter">;; </span><span class="org-comment">Set the project to publish upon running this script as well as how</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">to publish them</span>
(<span class="org-keyword">setq</span> org-publish-project-alist
      (list
       (list <span class="org-string">"website"</span>
             <span class="org-comment-delimiter">;; </span><span class="org-comment">Publish all files in the base directory</span>
             <span class="org-builtin">:recursive</span> t
             <span class="org-comment-delimiter">;; </span><span class="org-comment">Where the org-mode files are located</span>
             <span class="org-builtin">:base-directory</span> <span class="org-string">"./content"</span>
             <span class="org-comment-delimiter">;; </span><span class="org-comment">Where the HTML files are generated</span>
             <span class="org-builtin">:publishing-directory</span> <span class="org-string">"./public"</span>
             <span class="org-comment-delimiter">;; </span><span class="org-comment">Function to convert org-mode to desired format</span>
             <span class="org-builtin">:publishing-function</span> 'org-html-publish-to-html
             <span class="org-comment-delimiter">;; </span><span class="org-comment">Don't show the author in the footer</span>
             <span class="org-builtin">:with-author</span> nil
             <span class="org-comment-delimiter">;; </span><span class="org-comment">Add that site was generated with Emacs org-mode in footer</span>
             <span class="org-builtin">:with-creator</span> t
             <span class="org-comment-delimiter">;; </span><span class="org-comment">Don't add the table of contents</span>
             <span class="org-builtin">:with-toc</span> nil
             <span class="org-comment-delimiter">;; </span><span class="org-comment">Don't add section numbers in the headings</span>
             <span class="org-builtin">:section-numbers</span> nil
             <span class="org-comment-delimiter">;; </span><span class="org-comment">Don't include a time-stamp in the file</span>
             <span class="org-builtin">:time-stamp-file</span> nil)))</pre>

<p>
Finally, we&rsquo;ll tell Org Mode to regenerate the entire list of projects listed above each time we run the build script.
</p>

<pre><span class="org-comment-delimiter">;; </span><span class="org-comment">Generate the site output</span>
(org-publish-all t)</pre>

<p>
And then, just as a sanity check, we&rsquo;ll print a message letting us know we made it to the end.
</p>

<pre>(message <span class="org-string">"Build complete!"</span>)</pre>
</div>

<h3><a id="calling-the-build-script" class="anchor" href="#calling-the-build-script">¶</a>Calling the Build Script</h3><div class="outline-text-3" id="text-orgd9113a9">
<p>
Lastly, we just need to call Emacs to run this script in the shell. That&rsquo;s pretty quickly done in one line in a shell script, <code>build.sh</code>:
</p>

<pre>emacs -Q --script build-site.el</pre>

<p>
Here, the <code>-Q</code> flag tells Emacs not to load any configuration, splash screens, or anything else, and <code>--script</code> tells Emacs to run the Elisp script file we specify. Next, we can make the command executable by running
</p>

<pre>chmod +x build.sh</pre>

<p>
and finally, run the shell script that runs Emacs and the build script using
</p>

<pre>./build.sh</pre>

<p>
And now, barring any errors in performing the export, all of our Org Mode documents should have been exported to HTML files in the <code>public</code> subdirectory.
</p>
</div>
</div></div></div><footer class="site-footer"><div class="container"><div class="row"><div class="column"><p><a href="https://github.com/jdylanwhite">GitHub</a> · <a href="https://www.linkedin.com/in/jdylanwhite5">LinkedIn</a> · <a href="mailto:jdylanwhite5@gmail.com">Email</a></p></div><div class="column align-right"><p><a href="https://github.com/jdylanwhite/jdylanwhite.github.io">Site Source</a></p></div></div></div></footer></body></html>
